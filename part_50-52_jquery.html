<!DOCTYPE html>
<html>
<head>
	<title>Frontend. Заняття 50-52. jQuery.</title>
	<meta charset="utf-8">
	<meta name="keywords" content="">
	<meta name="description" content="">
	<meta name="format-detection" content="telephone=no">
	<link type="text/css" rel="stylesheet" href="css/styles.css">
</head>
<body>
<div id="mainwrapper">
	<div class="resize">

		<h1>jQuery.</h1>

		<section>
			<h2>Символ долара в імені змінної.</h2>
			<p>Ім'я змінної в класичному JS може складатися з символів латинського алфавіту в обох регістрах, цифр, символа підкреслення і знака долара. Ім'я змінної не повинно починатися з цифри:</p>
			<code>
				/[A-Za-z$_][A-Za-z0-9$_]*/
			</code>
			<p>Таким чином, <strong>$</strong> - символ, допустимий в імені змінної:</p>
			<code>
				var $name = 'Masha';<br>
				var $$$mony$$$ = '$ 300';<br>
				var xa$ker = { look: false };
			</code>
			<p>Протестуйте в консолі:</p>
			<code>
				var a = 5;<br>
				var $ = 7;<br>
				var price$ = a + $;<br>
				var gold_$_gold = a * $;<br>
				var $$$money$$$ = Math.pow(a, $);<br>
				console.log( price$ + ' ' + gold_$_gold + ' ' + $$$money$$$ );<br><br>
				function $(a, b, c){<br>
				&nbsp;&nbsp;return a + b + c;<br>
				}<br>
				console.log($(5, 7, 12));
			</code>
		</section>

		<section>
			<h2>Бібліотека функцій jQuery.</h2>
			<p><strong>jQuery</strong> - javascript-бібліотека, розроблена для полегшення роботи з DOM веб-сторінки та асинхронними запитами до сервера за технологією <a href="https://uk.wikipedia.org/wiki/AJAX" target="_blank">AJAX</a>.</p>
			<p><a href="http://jquery.com/" target="_blank">http://jquery.com</a> - домашня сторінка бібліотеки.</p>
			<p><a href="http://api.jquery.com/" target="_blank">http://api.jquery.com</a> - документація</p>
			<p><a href="http://code.jquery.com/" target="_blank">http://code.jquery.com</a> - версії</p>
			<p>Версії:</p>
			<code>
				1.x - підтримує старі версії браузерів, в т.ч. IE 6-7<br>
				2.x - прибрана підтримка старих версій браузерів<br>
				3.x - підтримуються тільки свіжі версії браузерів і такі, що мають значну долю ринку<br>
				3.x slim - "тонка" версія, видалено ajax та деякі функції, що рідко використовуються.
			</code>
			<h3>Підключення та використання jQuery.</h3>
			<p>Бібліотеки підключаємо в першу чергу, далі - плагіни, користувацькі скрипти - в останню чергу:</p>
			<code>
				&lt;script src="js/jquery-1.9.min.js"&gt;&lt;/script&gt;<br>
				&lt;script src="js/script.js"&gt;&lt;/script><br><br>
				&lt;script src="http://code.jquery.com/jquery-3.2.1.min.js"&gt;&lt;/script&gt;<br>
				&lt;script src="js/jquery.cycle2.min.js"&gt;&lt;/script&gt;<br>
				&lt;script src="js/script.js"&gt;&lt;/script&gt;
			</code>
			<p>Перевірте, чи підключена бібліотека jQuery до даної сторінки, введіть в консолі:</p>
			<code>
				jQuery
			</code>
			<p>Повторіть цю операцію до попередньої лекції.</p>
			<p>Для уникнення конфліктів з іншими бібліотеками, плагінами та користувацькими змінними код jQuery пишуть у функції-обгортці:</p>
			<code>
				(function($){<br>
				&nbsp;&nbsp;// код jQuery<br>
				&nbsp;&nbsp;...<br>
				})(jQuery);
			</code>
			<p>При цьому ми ізолюємо змінну з ім'ям значка долара лише межами даної функції.</p>
			<p>Всередині цього замикання можна використовувати як псевдонім, так і повне ім'я функції:</p>
			<code>
				(function($){<br>
				&nbsp;&nbsp;jQuery('.active').text('Active item');<br>
				&nbsp;&nbsp;$('.active').removeClass('active');<br>
				})(jQuery);
			</code>
			<p>Обгортки можуть мати різний вигляд, але суть у них одна - ізолювати змінну $.</p>
			<p>Заради справедливості - ви можете використовувати і повне ім'я функції, і псевдонім без всілякої обгортки:</p>
			<code>
				jQuery('.active').text('Active item');<br>
				$('.active').removeClass('active');
			</code>
			<p>Таким чином, <b>$ === jQuery</b>, в цьому можна переконатися переглянувши код внизу скрипта <a href="http://code.jquery.com/jquery-latest.js" target="_blank">code.jquery.com/jquery-latest.js</a>.</p>
		</section>

		<section>
			<h2>Вибір елементів DOM.</h2>
			<p>Основна задача jQuery - пошук елементів в DOM і робота з ними.</p>
			<p>Пошук елементів здійснюється по селектору:</p>
			<code>
				<strong>$(селектор).метод();</strong><br><br>
				$('#content .box').html('Hello!');<br>
				$('menu > li:first-child > a').css('color', 'red');
			</code>
			<p>jQuery повністю складається з функцій, є лише одна властивість - length.</p>
			<p>Все, що знаходить функція по селектору - це jQuery-набір елементів. Навіть якщо ми шукаємо один елемент по ідентифікатору. Навіть якщо серед багатьох елементів вибираємо один, це все одно буде масив з одного елемента. Якщо ж на сторінці не буде знайдено цього елемента - буде повернено порожній jQuery-набір, у якого length === 0.</p>
			<p>
				console.dir($('p'));<br>
				console.dir($('p').eq(0));<br>
				console.dir($('h1'));<br>
				console.dir($('.hello'));
			</p>
			<p>Масив цей - специфічний, він є обгорткою до колекції елементів js.</p>
			<code>
				var p = document.getElementsByTagName('p');<br>
				$(p) - jQuery-набір абзаців<br>
				$(document.body) - jQuery-набір з одного елемента body<br>
				$(window) - jQuery-window
			</code>
			<p>Функції jQuery можна застосовувати тільки до jQuery-наборів і не можна - до елементів JS.</p>
			<p>Ще одна особливість jQuery - ланцюжки викликів (або колбасіни викликів :).</p>
			<p>Ви можете до одного і того ж елемента застосувати декілька методів:</p>
			<code>
				$('a.active').removeClass('active').css('color', 'blue').attr('href', '#').children('span').addClass('hide').hide();
			</code>
			<p>Зверніть увагу, що методи застосовують модифікації до всього набору елементів, не потрібно робити перебір.</p>
			<p>Ланцюжки викликів можливо застосовувати тому що більшість методів повертає те, що приходить на вхід функції:</p>
			<code>
				jQuery.fn.addClass(function(cls){<br>
				&nbsp;&nbsp;this.forEach(function(elem){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;elem.classList.add(cls);<br>
				&nbsp;&nbsp;});<br>
				&nbsp;&nbsp;<strong>return this;</strong><br>
				});
			</code>
			<h3>Збереження елементів у змінні.</h3>
			<p>Не завжди можна обійтися одним ланцюжком викликів. Буває, що знайдені елементи потрібно використати декілька разів у різних частинах коду.</p>
			<p>Вважається поганою практикою робити повторні пошуки елементів, зайвий раз заставляти JS оббігати все дерево DOM в пошуку потрібних тегів, тому намагаємося робити чистий код, з мінімумом повторів пошуку.</p>
			<p>Серед розробників є негласна домовленість - змінну з результатом пошуку починати з символа долара, цим ми говоримо, що у змінній зберігається jQuery-набір:</p>
			<code>
				var p = document.getElementsByTagName('p');<br>
				var $p = $('p');<br>
				console.dir(p);<br>
				console.dir($(p));<br>
				console.dir($p);<br><br>
				console.dir($p[0]);<br>
				console.dir($p.get(0));<br>
				console.dir($p.eq(0));
			</code>
		</section>

		<section>
			<h2>Навігація по DOM.</h2>
			<p><strong>$('ul li').length;</strong> - кількість знайдених елементів.</p>
			<h3>Батьківські та дочірні елементи.</h3>
			<p><strong>$('p').parent();</strong> - знаходить безпосередніх батьків елементів.</p>
			<p><strong>$('p').parents();</strong> - знаходить всіх батьків елемента (що задовільняють параметру, якщо він заданий).</p>
			<p><strong>$('p').children();</strong> - знаходить безпосередні дочірні елементи.</p>
			<p><strong>$('ul').find(selector);</strong> - знаходить всі дочірні елементи.</p>
			<p>Можна задати селектор щоб знайти тільки потрібні елементи серед всіх:</p>
			<code>
				$('p').parent('article');<br>
				$('p').parents('.wrapper');<br>
				$('ul').children('.active');
			</code>
			<h3>Сусідні елементи.</h3>
			<p><strong>$('ul li.active').prev();</strong> - переходить до попереднього сестринського елемента.</p>
			<p><strong>$('ul li.active').next();</strong> - переходить до наступного сестринського елемента.</p>
			<p><strong>$('ul li.active').prevAll();</strong> - вибирає всі попередні сестринські елементи.</p>
			<p><strong>$('ul li.active').nextAll();</strong> - вибирає всі наступні сестринські елементи.</p>
			<p>Знову ж таки, вищезазначені методи можуть приймати в себе аргумент - селектор, що відфільтрує зайві елементи:</p>
			<code>
				$('p').prev('img');<br>
				$('section').next('section'); &nbsp;&nbsp; // wtf?<br>
				$('ul li.active').prevAll('.contacts');<br>
				$('ul li.active').nextAll('.contacts');
			</code>
			<h3>Робота з набором.</h3>
			<p><strong>$('ul li').first();</strong> - повертає перший елемент з набору.</p>
			<p><strong>$('ul li').last();</strong> - повертає останній елемент з набору.</p>
			<code>
				$('ul li').first('.active');<br>
				$('ul li').last('.active');
			</code>
			<p>У jQuery є декілька <a href="http://api.jquery.com/category/selectors/jquery-selector-extensions/" target="_blank">спеціальних селекторів</a>, що покращують читабельність коду та спрощують його:</p>
			<code>
				$('ul li:first');<br>
				$('ul li:last');<br>
				$('ul li:even');<br>
				$('ul li:odd');
			</code>
			<p><strong>$('ul li').get(4);</strong> - повертає 5-й <span class="danger">JS-елемент</span> зі знайдених (починаючи з 0).</p>
			<p><strong>$('ul li')[4]</strong> - аналогічно.</p>
			<p><strong>$('ul li').eq(4);</strong> - повертає 5-й <strong class="danger">jQuery-елемент</strong> зі знайдених (починаючи з 0).</p>
			<p><strong>$('ul li').each(fun);</strong> - виконує дію з кожним знайденим елементом.</p>
			<code>
				$('p').each(function(){<br>
				&nbsp;&nbsp;console.log($(this).text());<br>
				});<br><br>
				$('p').each(function(i, e){<br>
				&nbsp;&nbsp;console.log(i, $(e).text());<br>
				});
			</code>
			<h3>Фільтрація елементів:</h3>
			<p><strong>$('ul li').filter(':even').css('color', 'red');</strong> - відфільтровує елементи, в даному випадку залишає парні.</p>
			<p><strong>$('ul li').not('.active');</strong> - видаляє зі знайденого набору елементів ті елементи, що відповідають селектору.</p>
			<p><strong>$('p').add(...);</strong> - добавляє елементи до набора (аргумент - елементи або селектор).</p>
			<code>
				var $li = $('li');<br>
				$('p').add($li).add('img.gallery').addClass('js-elem');
			</code>
			<p><strong>$('li').index('.active');</strong> - повертає номер елемента в наборі, (індекс елемента LI.active серед всіх LI).</p>
			<p><strong>$('li').has('ul');</strong> - вибирає тільки ті елементи, які містять в собі елементи, що підходять під селектор в аргументі метода (вибрати всі LI в яких всередині є UL).</p>
			<p><strong>$('p').is(selector);</strong> - перевірка чи елемент підходить до селектора:</p>
			<code>
				$('li').each(function(){<br>
				&nbsp;&nbsp;if ($(this).is('.active')) { ... }<br>
				});
			</code>
		</section>

		<section>
			<h2>Робота з елементами.</h2>
			<p><strong>$('ul li').html();</strong> - повертає html-вміст першого елемента набору.</p>
			<p><strong>$('ul li').html('&lt;strong&gt;Hello!&lt;/strong&gt;');</strong> - задає html-вміст кожному елементу набору.</p>
			<p><strong>$('ul li').text();</strong> - повертає текстовий вміст першого елемента набору.</p>
			<p><strong>$('ul li').text('Hello!');</strong> - задає текстовий вміст кожному елементу набору.</p>
			<p><strong>$('p').css('color', 'rgba(255,12,64,0.4)');</strong> - змінює стиль у всіх елементів набору.</p>
			<p><strong>$('p').css({width: '32px', height: '60px', color: 'green'});</strong> - змінює декілька стилів у елементів.</p>
			<h3>Робота з атрибутами.</h3>
			<p><strong>$('p').addClass('active');</strong> - добавляє клас до всіх елементів.</p>
			<p><strong>$('p').removeClass('active');</strong> - видаяє клас зі всіх елементів.</p>
			<p><strong>$('p').toggleClass('active');</strong> - "переключає" клас: добавляє - якщо немає, видаляє - якщо є.</p>
			<p><strong>$('p').hasClass('active');</strong> - перевірка наявності класу хоча-б у одного елемента.</p>
			<p><strong>$('p').attr('title');</strong> - повертає значення атрибута першого елемента.</p>
			<p><strong>$('a').attr('href', 'http://google.com');</strong> - змінити значення атрибута у всіх елементів.</p>
			<p><strong>$('p').removeAttr('class');</strong> - видаляє атрибут у всіх елементів.</p>
			<p><strong>$('.checkbox').prop('checked');</strong> - робота зі станом елемента форми: checked, disabled... Метод повертає true чи false першого елемента в залежності від того, чи вказаний стан задано для елемента, чи ні.</p>
			<p><strong>$('.checkbox').prop('disabled', true);</strong> - змінює значення стану.</p>
			<p><strong>$('.checkbox').removeProp();</strong> - видаляє стан у всіх елементів.</p>
			<p><strong>$('p').data('value');</strong> - повертає значення атрибута data-value першого елемента.</p>
			<p><strong>$('p').data('value', '32 кг');</strong> - змінює значення атрибута data-value всім елементам (створює такий атрибут, якшо його немає).</p>
			<p><strong>$('p').removeData('value');</strong> - видаляє атрибут data-value у всіх елементів.</p>
			<p><strong>$('input[name="phone"]').val();</strong> - повертає введене значення першого елемента.</p>
			<p><strong>$('input[name="phone"]').val('0382-55-77-33');</strong> - змінює значення у всіх знайдених елементів.</p>
			<h3>Розміри та позиція елемента.</h3>
			<p><a href="http://jquery.page2page.ru/index.php5/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0_%D1%81_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D0%BE%D0%B9_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0" target="_blank">jquery.page2page.ru: Работа с шириной элемента</a>.</p>
			<p><a href="http://jquery.page2page.ru/index.php5/%D0%9F%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0" target="_blank">jquery.page2page.ru: Позиция элемента</a></p>
			<p><strong>$('#list').width();</strong> - повертає внутрішню ширину елемента (ширину контента).</p>
			<p><strong>$('#list').innerWidth();</strong> - повертає ширину елемента, включаючи паддінги.</p>
			<p><strong>$('#list').outerWidth();</strong> - повертає ширину елемента, включаючи паддінги та бордери.</p>
			<p><strong>$('#list').outerWidth(true);</strong> -  - повертає ширину елемента, включаючи паддінги, бордери та маргіни.</p>
			<p>
				Аналогічно для висоти елемента:<br>
				$('#list').height();<br>
				$('#list').innerHeigth();<br>
				$('#list').outerHeight();<br>
				$('#list').outerHeight(true);
			</p>
			<p><strong>$('#list').offset();</strong> - повертає координати лівої верхньої точки елемента відносно документа.</p>
			<p><strong>$('#list').position();</strong> - повертає координати лівої верхньої точки елемента відносно батьківського елемента.</p>
			<code>
				$('#list').offset().left;<br>
				$('#list').offset().top;<br>
				$('#list').position().left;<br>
				$('#list').position().top;<br><br>
				var o = $('h1').offset();<br>
				var p = $('h1').position();<br>
				alert(o.left);<br>
				console.log(p.top);
			</code>
		</section>

		<!-- split lection -->

		<section>
			<h2>Модифікація DOM в jQuery.</h2>
			<h3>Добавляння елементів та HTML.</h3>
			<p><em>$(куди_добавляємо).fun(що_добавляємо);</em></p>
			<p><strong>$('p').before(s);</strong> - вставляє HTML-код чи елемент перед кожним вибраним елементом.</p>
			<p><strong>$('p').after(s);</strong> - вставляє HTML-код чи елемент після кожного вибраного елемента.</p>
			<p><strong>$('p').prepend(s);</strong> - вставляє HTML-код чи елемент всередину кожного вибраного елемента на початок.</p>
			<p><strong>$('p').append(s);</strong> - вставляє HTML-код чи елемент всередину кожного вибраного елемента в кінець.</p>
			<code>
				var $strong = $('strong:first');<br>
				var img = document.createElement('img');<br>
				img.setAttribute('src', 'https://68.media.tumblr.com/avatar_5295b088c685_128.png');<br><br>
				$('p').before('&lt;hr&gt;');<br>
				$('p').after(img);<br>
				$('h2').prepend('&lt;span class="danger"&gt;!!! >>> &lt;/span&gt;');<br>
				$('h2').append($strong);
			</code>
			<h3>Добавляння елементів та HTML до цільового елемента.</h3>
			<p><em>$(що_добавляємо).fun(куди_добавляємо);</em></p>
			<p><strong>$(e).insertBefore(target);</strong> - добавляє перед елементом.</p>
			<p><strong>$(e).insertAfter(target);</strong> - добавляє після елемента.</p>
			<p><strong>$(e).prependTo(target);</strong> - добавляє всередину на початок елемента.</p>
			<p><strong>$(e).appendTo(target);</strong> - добавляє всередину в кінець елемента.</p>
			<code>
				var tgt = $('h2');<br>
				var $strong = $('strong:first');<br>
				var img = document.createElement('img');<br>
				img.setAttribute('src', 'https://68.media.tumblr.com/avatar_5295b088c685_128.png');<br><br>
				$('&lt;hr&gt;').insertBefore(tgt);<br>
				$(img).insertAfter(tgt);<br>
				$('&lt;span class="danger"&gt;!!! >>> &lt;/span&gt;').prependTo(tgt);<br>
				$($strong).append('h2');
			</code>
			<h3>Створення та видалення елементів.</h3>
			<p><strong>$(e).clone();</strong> - клонує елементи у пам'ять.</p>
			<code>
				$('#userpic').clone().prependTo('.comment');<br>
				$('button.calc').clone(true);<br>
				$('menu').clone(<a href="https://api.jquery.com/clone/" target="_blank">true, true</a>);
			</code>
			<p><strong>$('ul').empty();</strong> - видаляє всі дочірні елементи (очищає вибрані елементи).</p>
			<p><strong>$('li').remove();</strong> - видаляє вибрані елементи.</p>
			<p><strong>$('li').detach();</strong> - видаляє вибрані елементи і повертає їх.</p>
			<code>
				$('section').eq(0).empty();<br>
				$('section').eq(1).html('');<br>
				$('section').get(2).innerHTML = ''<br><br>
				$('h2').eq(0).remove();<br><br>
				var $li = $('ol li').each(function(i){<br>
				&nbsp;&nbsp;$(this).prepend('[' + i + '] ');<br>
				}).filter(':even').detach();<br>
				window.onclick = function(){<br>
				&nbsp;&nbsp;$('ol').eq(0).prepend($li);<br>
				}
			</code>
			<p>Методи remove і detach можуть приймати аргумент - селектор, для фільтрації елементів, що будуть видалені.</p>
			<h3>Обгортки.</h3>
			<p><strong>$(e).wrap(html);</strong> - робить обгортку довкола кожного з вибраних елементів.</p>
			<p><strong>$(e).wrapAll(html);</strong> - робить одну спільну обгортку для всіх вибраних елементів.</p>
			<p><strong>$(e).wrapInner(html);</strong> - робить обгортку для контента кожного вибраного елемента (огортає всередині).</p>
			<p><strong>$(e).unwrap();</strong> - видаляє обгортку (безпосереднього батька).</p>
			<code>
				$('h2').wrap('&lt;div class="h2-wrap"&gt;&lt;/div&gt;');<br>
				$('.h2-wrap').css('border', '1px solid blue');<br>
				$('h2').wrapInner('&lt;span class="danger"&gt;&lt;/span&gt;');<br>
				$('li').wrapAll('ul');<br>
				$('h1').unwrap('.resize');
			</code>
			<p>Метод unwrap може приймати селектор, якщо батьківський елемент не відфільтрується ним, то обгортка не видалиться.</p>
		</section>

		<section>
			<h2>Події (events):</h2>
			<p><strong>$('p').click(function(e){ ... });</strong> - добавити елементам обробник події кліка.</p>
			<p><strong>$('input.text').change(function(e){ ... });</strong> - змінилося значення елемента форми (викликається при втраті фокуса).</p>
			<p><strong>$('input.text').focus(f).blur(f);</strong> - отримання та втрата фокуса елементом форми, посиланням.</p>
			<p><strong>$('input.text').hover(f, f);</strong> - ховер-ефект: дві функції на отримання і втрату ховера.</p>
			<p><strong>$('input.text').keydown(f).keyup(f).keypress(f);</strong> - події клавіатури.</p>
			<p><strong>$('img').mousedown(f).mouseup(f).mouseenter(f).mouseleave(f).mousemove(f)....;</strong> - події миші.</p>
			<p><strong>$('img').load(f);</strong> - елемент завантажено (використовується для ресурсів, документа).</p>
			<p><strong>$('body').ready(f).unload(f);</strong> - події готовності до використання, вигрузки елемента.</p>
			<p><strong>$(window).resize(f).scroll(f).beforeunload(f);</strong> - події на зміну розміра, скролл, закриття вкладки.</p>
			<h3>Робота з прослуховувальником подій.</h3>
			<p><strong>$('img').on('event_name', function(e){ ... });</strong> - добавити елементам обробник події.</p>
			<p><strong>$('img').off('event_name');</strong> - видалення обробника події.</p>
			<p><strong>$('img').one('event_name', function(event){ ... });</strong> - обробник події спрацює лише один раз і сам автоматично видалиться.</p>
			<p>.live(), .bind(), .deletage() - застарілі методи.</p>
			<h3>Делегація подій від батьківських елементів до дочірніх.</h3>
			<p>Наприклад, у нас динамічно створюються кнопки. Після створення кожної кнопки на неї потрібно вішати обробник подій.</p>
			<p>Можна піти іншим шляхом: обробник подій задати батьківському елементу, і вказати ціль, що викликатиме подію:</p>
			<code>
				<strong>$(parent).on(event, target, handler);</strong><br>
				$('#buttons').on('click', 'button', function(e){ ... });
			</code>
			<p>При кліку в межах батьківського елемента метод перевіряє який елемент знаходиться в event.target, перевіряє, чи підходить він під вказаний другим аргументом селектор, і якщо підходить, то подія викликається від його імені.</p>
		</section>

		<section class="homework">
			<h2>Домашнє завдання.</h2>
			<ol>
				<li>Збережіть собі в папку нового проекту файл <a href="part_50_homework.html" target="_blank">part_50_homework.html</a>, підключіть jQuery і файл ваших скриптів script.js.</li>
				<li>Дослідіть стилі даного файла, по можливості запам'ятайте назви класів.</li>
				<li>Виведіть в консоль кількість елементів списку .rainbow, приклад: "Rainbow count: 7".</li>
				<li>Добавте клас 'active' до списка .rainbow і всі елементи розфарбуйте у відповідні кольори класами col*.</li>
				<li>Виведіть в консоль текст і html-код елемента .bl цього списку.</li>
				<li>В списку #test розфарбуйте елементи test червоним кольором класом .active, елементи subtest - класом .passive.</li>
				<li>Першому елементу кожного списка сторінки задайте класом синю тінь для текста, останньому - зелену.</li>
				<li>Елементу .lol мають передувати 2 елемента з синьою та зеленою тінню, а також наступні 2 елемента повинні мати синю та зелену тінь. Висоту елемента .lol задати 40px, розмір шрифта і lineheight - 24px / 28px.</li>
				<li>В списку з title="links" текст посилань зробіть відповідним до його href (скопіюйте href у text).</li>
				<li>Посилання на FTP пофарбуйте класом у зелений колір.</li>
				<li>Знайдіть елемент .special, додайте його батьку клас 'specwrap', батьківському елементу .silver додайте клас 'active'.</li>
				<li>Пронумеруйте всіх батьків елемента .special атрибутом data-parent="..." числами 1, 2, 3, 4... починаючи від безпосереднього батька. Перегляньте код елементів у інспекторі об'єктів, має бути щось типу такого: &lt;strong data-parent="1"&gt;</li>
				<li>Візьміть елемент #test, знайдіть всіх його дітей першого порядку (ті, що з текстом test), окрім елемента .lol, зробіть текст літерами у верхньому регістрі, додавши клас .upper.</li>
				<li>В елементі .week виберіть дітей 's, em, i, .big', скориставшись методом .filter(), добавте до них клас 'passive', щоб задати світлосірий колір тексту.</li>
				<li>В списку ul[title="links"] перед кожним елементом http-посилання добавте &lt;li&gt;_________&lt;/li&gt;, а після кожного ftp-посилання - &lt;li&gt;^^^^^^^^^&lt;/li&gt;.</li>
				<li>В списку #test кожному елементу "test" добавте на початок &lt;b>!!!&lt;/b>, а до елементів subtest добавте в кінець &lt;i>???&lt;/i>.</li>
				<li>Клонуйте список #test та добавте його в кінець веб-сторінки. Зауважте, що на одній сторінці не повинно бути двох елементів з однаковим id.</li>
				<li>Пронумеруйте елементи списку #test: 1. test, 2. test і т.д., видаліть кожен парний елемент списку (бажано без циклу, селектором <strong>:even</strong>). Якщо при цьому буде видалено список з елементами subtest, то змініть умову задачі: потрібно видалити непарні елементи.</li>
				<li>Очистіть елементи списку "subtest".</li>
				<li>Огорніть елементи .week та .week2 тегом div.col5.</li>
				<li>Огорніть всі списки разом тегом section.</li>
				<li>Виберіть всіх дітей елемента .week, і огорніть їх контент тегом span.check.</li>
				<li>Якщо зажати Shift і водити мишу по екрану - в консоль повинні виводитися імена тегів елементів, на які наводиться миша.</li>
				<li>При кліку на елементи списку .rainbow виводьте alert з іменем класу цього елемента і кольором фону через пробіл.</li>
				<li>При отриманні фокуса текстових полів форми підсвічуйте їх жовтим фоном (.col3).</li>
				<li>Виводьте в консоль букви, які нажимає користувач, знаходячись в текстових полях. Забороніть в полі телефона натискання клавіші 0 (return false;).</li>
				<li>Зніміть властивість checked з радіокнопок, добавте цю властивість до чекокса.</li>
				<li>Для елемента .check добавте метод, щоб при кліку в нього змінювався стан (клас 'active') і при цьому переключався чекбокс.</li>
				<li>При кліку на дітей елемента .week повинні з’являтися alert’и з текстом, що міститься в цих елементах.</li>
				<li>Аналогічно у елементів .week2, але якщо є атрибут data-click, то алерт має вивестися не більше стількох раз, як вказано в цьому параметрі, а якщо немає цього параметра - лише 1 раз.</li>
				<li>Добавте до .week ще один елемент &lt;b&gt;newday&lt;/b&gt;, переконайтесь, що клік на нього не працює. Модифікуйте обробник подій так, щоб після динамічного створення цього елемента він також би ловив подію кліка.</li>
				<li>В список .wave добавте 30 елементів з текстом 'wave', зробіть "стадіонну хвилю" - при наведенні на елемент йому задається клас .wave1, його сусідам - .wave2, далі сусідам - .wave3, 4 і т.д. до .wave8.</li>
			</ol>
		</section>

		<section>
			<h2>Для чого вам jQuery.</h2>
			<p>Ви можете знайти багато інформації, думок про те, що "<a href="https://habrahabr.ru/post/259223/" target="_blank">скрипач не нужен</a>".</p>
			<p>Зазвичай автори цих статей і думок мало займаються фронтенд-кодінгом, більше спеціалізуючись на бекенді або займають якусь певну нішу типу обміну даними з сервером, спеціалісти з різноманітних ангулярів, нод і т.п.</p>
			<p>Для чого потрібно знати jQuery:</p>
			<ol>
				<li>Цього вимагають роботодавці.</li>
				<li>jQuery став еталоном для багатьох інших бібліотек, їх будова, принципи роботи схожі з jQuery, тому розібратися в них вам буде значно простіше, швидше.</li>
				<li>Величезна база зручних jQuery-плагінів нікуди не дінеться ще багато років, для багатьох плагінів, типу слайдерів (галерей), таблиць даних немає ніяких адекватних альтернатив.</li>
				<li>В jQuery методи названі логічніше, працюють зрозуміліше, ніж в JS, тому бібліотеку можна вивчити за лічені години і писати складний код.</li>
				<li>Анімацію на JS досі доволі складно реалізувати, в CSS далеко не все працює так, як того хотілося б.</li>
				<li>Можна вигадувати свої велосипеди, але вони точно не будуть працювати швидше, розмір бібліотеки не буде меншим.</li>
				<li>jQuery - найрозповсюдженіша бібліотека, регулярно оновлюється, на відміну від багатьох своїх конкурентів.</li>
				<li>Принципова відмова від jQuery в проекті вимагає шукати більш досвідчених розробників, здорожчує проект за рахунок зарплат та витрат часу на розробку.</li>
			</ol>
			<p>Багато моментів, про які писала пані Lea Verou (проблеми з переходом від натівних об'єктів до jQuery-об'єктів і назад, багатократне огортання змінних в оболонку) говорить не в її користь, про її недосвідченість, недостатню практику у jQuery, а також незнання цієї бібліотеки: в реальних великих проектах не так часто є потреба весь час скакати між натівними об'єктами та оболонкою. В маленьких проектах часто такі переходи взагалі не зустрічаються (окрім огортання this). Заплюсовані коментарі після статті в основному на підтримку jQuery.</p>
			<p>Резюмуючи вищесказане - <strong>до всього необхідно підходити з розумом</strong>:</p>
			<ol>
				<li>Не варто підключати jQuery якщо вам хочеться скоротити свій JS з 20 строк кода до 5 (5 строк кода + файлик на 60 кб).</li>
				<li>Не варто підключати jQuery заради двох простих маленьких анімацій.</li>
				<li>Не варто підключати jQuery якщо хочеться використати простенький плагін, який можна написати за 5 хвилин на чистому JS.</li>
				<li>Варто підключити jQuery, якщо ви активно використовуєте інші бібліотеки і плагіни, залежні від нього (наприклад, бутстрап).</li>
				<li>Варто підключити jQuery, якщо є альтернатива підключити декілька різних, менш популярних бібліотек, що реалізують потрібну вам функціональність: для роботи з DOM + для роботи з анімацією + для роботи з AJAX + для роботи з подіями (подружити між собою декілька різнокаліберних бібліотек буває значно важче, ніж використати одну універсальну).</li>
				<li>Варто підключити jQuery, якщо проект розробляють джуни, а не профі.</li>
				<li>Варто підключити jQuery, якщо вам терміново в короткі строки потрібно написати складний плагін.</li>
				<li>Варто оцінити свої можливості, і якщо є такі можливості, щоб відмовитися від jQuery - від нього варто відмовитися, якщо таких можливостей немає - краще його підключити і застосовувати.</li>
			</ol>
			<p>jQuery - лише інструмент, доволі хороший, як молоток, зручний, дешевий, на всі 100% виконує свої функції.<br>В майстерні він необхідний, але навряд чи ви його будете застосовувати під час клеяння кораблика із сірників чи пришивання гудзика до сорочки.</p>
		</section>

	</div>
</div>

<script src="js/jquery-3.1.1.min.js"></script>

</body>
</html>